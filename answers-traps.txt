1、a0-a7包含函数参数；a2存储13
(根据第45行代码，可以看到13被放到了a2寄存器中。猜测是a0-a7寄存器保存参数。)
2、编译器优化后，无函数调用
(其实是没有这样的代码。g(x)被内联到f(x)中，然后f(x)又被进一步内联到main()中。所以看到的不是函数跳转，而是优化后的内联函数。)
3、0x630                         
(首先将当前程序计数器的值赋给ra寄存器。auipc ra, 0x0，是指将当前立即数向右移动12位，然后加上pc寄存器的值，赋给ra寄存器，由于立即数为0，因此ra的值即为pc的值。当前指令在0x30处，因此pc = 0x30。1536(ra)是指1536加上ra寄存器的值，1536转为16进制再加上0x30即为0x0000000000000630。刚好是printf的地址。)
4、0x30，执行aupic ra,0x0，将PC寄存器值放到ra中    
(jalr指令会将pc+4赋给当前寄存器，刚好是其下一条指令的地址。)
5、输出：HE110 WORLD；如果risc-v是大端序，i需要设置为0x726c64，57616不需要变
(％x表示以十六进制数形式输出整数，57616的16进制表示就是e110，与大小端序无关。%s是输出字符串，以整数i所在的开始地址，按照字符的格式读取字符，直到读取到‘\0’为止。当是小端序表示的时候，内存中存放的数是：72 6c 64 00，刚好对应rld。当是大端序的时候，则反过来了，因此需要将i以16进制数的方式逆转一下。)
6、输出a2寄存器中的值
(printf接收到了两个参数，但实际需要三个参数，最后一个参数是放在a2寄存器中，由于没有输入第三个参数，因此a2寄存器中目前有啥就输出啥。)
